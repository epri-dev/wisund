// ===========================================================================
// Copyright (c) 2017, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// wisund ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 
// ###########################################################################
// GNU General Public License version 2
// ###########################################################################
//
// * mongoose v6.5 (https://github.com/cesanta/mongoose)
//
// Copyright (c) 2004-2013 Sergey Lyubka
// Copyright (c) 2013-2015 Cesanta Software Limited
// All rights reserved
//
// This software is dual-licensed: you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation. For the terms of this
// license, see <http://www.gnu.org/licenses/>.
//
// You are free to use this software under the terms of the GNU General
// Public License, but WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// Alternatively, you can license this software under a commercial
// license, as set out in <https://www.cesanta.com/license>.
//

/** 
 *  \file SerialDevice.cpp
 *  \brief Implementation of the SerialDevice class
 */
#include "SerialDevice.h"
#include <thread>
#include <functional>
#include <iomanip>

static constexpr uint8_t END{0xc0};
static constexpr uint8_t ESC{0xdb};
static constexpr uint8_t ESC_END{0xdc}; 
static constexpr uint8_t ESC_ESC{0xdd};

SerialDevice::SerialDevice(SafeQueue<Message> &input, SafeQueue<Message> &output, const char *port, unsigned baud) :
    Device(input, output),
    m_io(), 
    m_port(m_io, port),
    m_verbose{false},
    m_raw{false},
    m_delay{0}
{
    m_port.set_option(asio::serial_port_base::baud_rate(baud));
}

SerialDevice::SerialDevice(SafeQueue<Message> &input, SafeQueue<Message> &output, const std::string &port, unsigned baud) :
    Device(input, output),
    m_io(), 
    m_port(m_io, port.c_str()),
    m_verbose{false},
    m_raw{false},
    m_delay{0}
{
    m_port.set_option(asio::serial_port_base::baud_rate(baud));
}

SerialDevice::~SerialDevice() = default;

int SerialDevice::runTx(std::istream *in)
{
    in = in;
    if (wantHold()) {
        startReceive(); 
    }
    return 0;
}

int SerialDevice::runRx(std::ostream *out)
{
    out = out;
    Message m{};
    while (wantHold()) {
        wait_and_pop(m);
        send(m);
    }
    m_port.close();
    return 0;
}

int SerialDevice::run(std::istream *in, std::ostream *out)
{
    std::thread t1{&SerialDevice::runRx, this, out};
    int status = runTx(in);
    m_io.run();
    t1.join();
    return status;
}

using iterator = asio::buffers_iterator<asio::streambuf::const_buffers_type>;

static std::pair<iterator, bool> match_slip(iterator begin, iterator end) {
    // find the first
    iterator first = begin;
    for ( ; first != end && static_cast<uint8_t>(*first) != END; ++first) 
    { /* just find the first */ }
    if (first == end) {
        return std::make_pair(begin, false);
    }
    // found first; now find second
    iterator last = first;
    for ( ++last ; last != end; ++last) {
        if (static_cast<uint8_t>(*last) == END) {
            return std::make_pair(++last, true);
        }
    }
    return std::make_pair(begin, false);
}

void SerialDevice::startReceive() {
    asio::async_read_until(m_port, 
        m_data, 
        match_slip,
        std::bind(&SerialDevice::handleMessage, this, std::placeholders::_1, std::placeholders::_2));
}

void SerialDevice::handleMessage(const::asio::error_code &error, std::size_t size) {
    if (error) {
        return;
    }
    auto buf = m_data.data();
    std::vector<uint8_t> v(size);
    asio::buffer_copy(asio::buffer(v), buf);
    Message msg{v};
    if (m_verbose) {
        if (m_raw) {
            std::cout << "received: " << SerialDevice::decode(msg) << "\n";
        } else {
            std::cout << "received: " << msg << "\n";
        }
    }
    push(SerialDevice::decode(msg));
    m_data.consume(size);
    if (wantHold()) {
        startReceive();
    }
}

size_t SerialDevice::send(const Message &msg) {
    if (msg.size() == 0) {
        return 0;
    }
    auto encoded = encode(msg);
    if (m_verbose) {
        if (m_raw) {
            std::cout << "sending: " << msg << "\n";
        } else {
            std::cout << "sending: " << encoded << "\n";
        }
    }
    std::this_thread::sleep_for(m_delay);
    return m_port.write_some(asio::buffer(encoded.data(), encoded.size()));
}

bool SerialDevice::verbosity(bool verbose) {
    std::swap(verbose, m_verbose);
    return verbose;
}

bool SerialDevice::setraw(bool rawpackets) {
    std::swap(rawpackets, m_raw);
    return rawpackets;
}

void SerialDevice::sendDelay(std::chrono::duration<float, std::milli> delay) {
    m_delay = delay;
}

Message SerialDevice::encode(const Message &msg) {
    // wrap the payload inside 0xC0 ... 0xC0 
    Message ret{END};
    for (const auto &byte : msg) {
        switch (byte) {
        case END:
            ret.push_back(ESC);
            ret.push_back(ESC_END);
            break;
        case ESC:
            ret.push_back(ESC);
            ret.push_back(ESC_ESC);
            break;
        default:
            ret.push_back(byte);
        }
    }
    ret.push_back(END);
    return ret;
}

Message SerialDevice::decode(const Message &msg) {
    std::vector<uint8_t> ret; 
    uint8_t prev = msg.front();
    for (auto it = msg.begin(); it != msg.end(); ) {
        switch(*it) {
            case END:
            case ESC:
                // do nothing
                break;
            case ESC_END:
                ret.push_back(prev == ESC ? END : ESC_END);
                break;
            case ESC_ESC:
                ret.push_back(prev == ESC ? ESC : ESC_ESC);
                break;
            default:
                ret.push_back(*it);
        }
        prev = *it++;
    }
    return Message{ret};
}
