// ===========================================================================
// Copyright (c) 2017, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// wisund ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 
// ###########################################################################
// GNU General Public License version 2
// ###########################################################################
//
// * mongoose v6.5 (https://github.com/cesanta/mongoose)
//
// Copyright (c) 2004-2013 Sergey Lyubka
// Copyright (c) 2013-2015 Cesanta Software Limited
// All rights reserved
//
// This software is dual-licensed: you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation. For the terms of this
// license, see <http://www.gnu.org/licenses/>.
//
// You are free to use this software under the terms of the GNU General
// Public License, but WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// Alternatively, you can license this software under a commercial
// license, as set out in <https://www.cesanta.com/license>.
//

/** 
 *  \file Simulator.cpp
 *  \brief Implementation of the Simulator class
 */
#include "Simulator.h"
#include <thread>
#include <map>
#include <stdexcept>

/// constructor takes references to input and output queues, serial port and baud rate
Simulator::Simulator(SafeQueue<Message> &input, SafeQueue<Message> &output) :
    Device(input, output),
    m_verbose{false},
    m_delay{0},
    lastMessage{}
{}

/// destructor is virtual in case class needs to be further derived
Simulator::~Simulator() = default;

/// runs both the receive and transmit handlers in required sequence
int Simulator::run(std::istream *in, std::ostream *out)
{
    in = in;
    out = out;
    Message m{};
    while (wantHold()) {
        wait_and_pop(m);
        send(m);
        receive();
    }
    return 0;
}
//
/// set or clear verbose flag and return previous state
bool Simulator::verbosity(bool verbose)
{
    std::swap(verbose, m_verbose);
    return verbose;
}

/// set optional pre-send delay time 
void Simulator::sendDelay(std::chrono::duration<float, std::milli> delay) 
{
    m_delay = delay;
}

/// encodes and sends a message
size_t Simulator::send(const Message &msg) 
{
    if (msg.size() == 0) {
        return 0;
    }
    if (m_verbose) {
        std::cout << "sending: " << msg << "\n";
    }
    std::this_thread::sleep_for(m_delay);
    lastMessage = msg;
    return msg.size();
}

/// container for test messages that get replies
struct cmdDetails {
    Message response;
    const char *command;
    const char *json;
};

static std::map<Message, cmdDetails> simCmd =
{
    {
        {{0x06,0x22}}, { {{ 0x22,0x4a,0x61,0x6e,0x20,0x33,0x30,0x20,0x32,0x30,0x31,0x37,0x20,0x30,0x39,0x3a,0x31,0x35,0x3a,0x35,0x38,0x20,0x31,0x76,0x30,0x31,0x44,0x30,0x34}}, 
        "buildid", R"({ "buildid":"Jan 30 2017 09:15:58 1v01D04" })", }
    },
    { 
        {{0x06, 0x20}}, { {{0x20, 0x01, 0x01, 0x04}},
        "state", R"({ "mode":"LBR", "neighbors":1, "discoveryState":4 })", }
    },  
    { 
        {{0x06,0x24}}, { {{0x24,0x00,0x19,0x59,0xff,0xfe,0x0f,0xff,0x01}},
        "mac", R"({ "mac":"00:19:59:ff:fe:0f:ff:01" })", }
    },
    { 
        {{0x06, 0x21, 0x01}}, { {{0x21,0x01,0x42,0xfc,0x42,0x00,0x6f,0x00,0x00,0x00,0x00,0x00,0x01,0xe3,0x00,0x00,0xfe,0xca,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x59,0xff,0xfe,0x0f,0xff,0x02}},
        "diag 01", R"({ "addrinfo": { "time":4389954, "acceptedframes":111, "rejectedaddresses":0, "recvdmhr":58113, "lastrcvddstpanid":"0000", "lastrcvdsrcpanid":"feca", "lastrejectaddr":"00:00:00:00:00:00:00:00", "lastrcvdaddr":"00:19:59:ff:fe:0f:ff:02" } })", }
    },
    { 
        {{0x06, 0x21, 0x02}}, { {{0x21,0x02,0x00,0x00,0x00,0x00,0x73,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x73,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x6f,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,}},
        "diag 02", R"({ "iecounters": { "fcie":0, "uttie":115, "rslie":0, "btie":4, "usie":115, "bsie":4, "panie":4, "netnameie":111, "panverie":4, "gtkhashie":4, "mpie":0, "mhdsie":0, "vhie":0, "vpie":0 } })", }
    },
    { 
        {{0x06, 0x21, 0x03}}, { {{0x21,0x03,0x37,0x00,0x00,0x00,0x74,0xc1,0x20,0x07,0x74,0xe1,0x20,0x07,0x74,0xe1,0x0e,0x05,0x74,0xd1,0x20,0x07,0xb4,0xe1,0x20,0x07,0xb4,0x91,0x0e,0x05,0x74,0xd1,0x0e,0x05,0x74,0xe1,0x0e,0x05,0x34,0x91,0x0e,0x05,0x74,0x91,0x0e,0x05,}},
        "diag 03", R"({ "ieunknown": { "count":55, "rejected": [ { "desc":49524, "subdesc":1824}, { "desc":57716, "subdesc":1824}, { "desc":57716, "subdesc":1294}, { "desc":53620, "subdesc":1824}, { "desc":57780, "subdesc":1824}, { "desc":37300, "subdesc":1294}, { "desc":53620, "subdesc":1294}, { "desc":57716, "subdesc":1294}, { "desc":37172, "subdesc":1294}, { "desc":37236, "subdesc":1294} ] } })", }
    },
    { 
        {{0x06, 0x21, 0x04}}, { {{0x21,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,}},
        "diag 04", R"({ "mpxie": { "timestamp":0, "mpxie_count":0, "mpx_id":0, "mpx_subid":0, "msdulength":0, "srcaddr":"00:00:00:00:00:00:00:00", "destaddr":"00:00:00:00:00:00:00:00" } })", }
    },
    { 
        {{0x06, 0x21, 0x05}}, { {{0x21,0x05,0x00,0x13,0x56,0x4a,0x00,0x05,0x0a,0xfa,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x01,0x02,0x00,0xc5,0x0d,0x00,0x90,0x01,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,}},
        "diag 05", R"({ "fhieinfo": { "index":0, "timestamp":4871699, "clock_drift":5, "timestamp_accuracy":10, "unicast_dwell":250, "broadcast_dwell":0, "broadcast_interval":0, "broadcast_schedule_id":0, "channel_plan":0, "channel_function":2, "reg_domain":1, "operating_class":2, "ch0":902400, "channelspacing":400, "number_channels":64, "fixed_channel":0, "excludedchanmask":"0000000000000000000000000000000000" } })", }
    },
    { 
        {{0x06, 0x21, 0x06}}, { {{0x21,0x06,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,}},
        "diag 06", R"({ "mysequence": [ { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0} ] })", }
    },
    { 
        {{0x06, 0x21, 0x07}}, { {{0x21,0x07,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,}},
        "diag 07", R"({ "targetseq": [ { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0}, { "slot":0, "chan":0} ] })", }
    },
    { 
        {{0x06, 0x21, 0x08}}, { {{0x21,0x08,0x00,0x06,0x17,0x4d,0x00,0x1e,0x4a,0x43,0x00,0x61,0xb6,0x41,0x00,0x00,0x2b,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xca,0x01,0x00,0x21,0x43,0x65,0x87,0x00,0x00,0x00,0x00,0x22,0x43,0x65,0x87,0x00,0x00,0x00,0x00,0x24,0x43,0x65,0x87,0x00,0x00,0x00,0x00,0x24,0x43,0x65,0x87,0x00,0x00,0x00,0x00,}},
        "diag 08", R"({ "fhnbinfo": { "index":0, "timestamp":5052166, "lastrcvdufsi":4409886, "neighborlastms":4306529, "lastrslrssi":0, "rawmeasrssi":43, "lastrcvdbfi":0, "lastrcvdbsn":0, "panid":"feca", "panversion":1 } })", }
    },
    { 
        {{0x06, 0x21, 0x09}}, { {{0x21,0x09,0x7a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7a,0x00,0x00,0x00,0x3a,0x00,0x2b,0x60,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,}},
        "diag 09", R"({ "radiostats": { "rxcount":122, "fifoerrors":0, "crcerrors":0, "rxinterrupts":122, "lastrxlen":58, "rssi":43, "txinterrupts":352, "spuriousints":0, "txerrors":0, "txpackets":352, "txfifoerr":0, "txchipstat":15 } })", }
    },
    {
        {{0x06, 0x21, 0x0a}}, { {{0x21,0x0a,0x48,0x14,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,}},
        "diag 0a", R"({ "macstats": {  "timestamp":136264, "dataRequest":0, "dataRequestError":0, "dataSendError":0, "dataIndication":0, "retransmission":0, "ackFailure":0, "inFrameOverflow":0 } })", },
    },
    { 
#if 0
        {{0x06,0x23,}}, { {{0x23,0x01,0x00,0x01,0x7e,0x02,0x4e,0x00,0x00,0x19,0x59,0xff,0xfe,0x0f,0xff,0x02}},
        "neighbors", R"({ "neighbors": [ { "index":0, "validated":1, "timestamp":5112446, "mac":"00:19:59:ff:fe:0f:ff:02"} ] })", }
#else
        {{0x06,0x23,}}, { {{0x23,0x02,0x00,0x01,0x7e,0x02,0x4e,0x00,0x00,0x19,0x59,0xff,0xfe,0x0f,0xff,0x02,0x01,0x01,0x7f,0x02,0x4e,0x00,0x00,0x19,0x59,0xff,0xfe,0x0f,0xff,0x03}},
        "neighbors", R"({ "neighbors": [ { "index":0, "validated":1, "timestamp":5112446, "mac":"00:19:59:ff:fe:0f:ff:02"}, { "index":1, "validated":1, "timestamp":5112447, "mac":"00:19:59:ff:fe:0f:ff:03"}  ] })", }
#endif
    },
};

/// receive simulated message from simulated device
void Simulator::receive() 
{
    static uint32_t fcie = 600;
    try {
        Message msg{simCmd.at(lastMessage).response};
        if (msg[0] == 0x21 && msg[1] == 2) {
            ++fcie;
            msg[2] = (fcie >> 0) & 0xff;
            msg[3] = (fcie >> 8) & 0xff;
            msg[4] = (fcie >> 16) & 0xff;
            msg[5] = (fcie >> 24) & 0xff;
        }
        if (m_verbose) {
            std::cout << "received: " << msg << "\n";
        }
        push(msg);
    }
    catch (std::out_of_range const &err) {
        // do nothing; it just means this command gets no response
    }
    // probably pedantic, but clear the last message
    lastMessage.clear();
}
